from sklearn.metrics import classification_report
from dataloader import load_train_data, load_test_data
from gem import GEMDetector
import utils
import numpy as np
import torch

def main():
    # Load and scale training data.
    S1_loaded, S2_loaded, scaler = load_train_data(parquet_path='smallCiCDDoS/NTP-testing.parquet')
    
    # Combine S1_loaded and S2_loaded to form the full nominal training dataset for the new GEMDetector
    nominal_training_data = np.concatenate((S1_loaded, S2_loaded), axis=0)
    print("âœ… Full Nominal Training data for GEMDetector (combined S1+S2) loaded:", nominal_training_data.shape)

    # Load test data (X_test is initially unscaled)
    X_test_unscaled, y_test = load_test_data(parquet_path='smallCiCDDoS/NTP-testing.parquet')
    # Scale X_test using the same scaler fitted on the training data (S1)
    X_test = scaler.transform(X_test_unscaled)
    print("âœ… Scaled Test data loaded: X_test=", X_test.shape, ", y_test=", y_test.shape)

    # --- Initialize the new GEMDetector with its specific parameters ---
    # k: Number of nearest neighbors for d_j and d_t calculation (sum of distances).
    # s1_ratio: Ratio for the internal S1/S2 split within the detector's 'fit' method.
    #           (e.g., 0.8 means 80% of nominal_training_data goes to internal S1, 20% to internal S2).
    # alpha: Significance level for calibrating CUSUM threshold 'h' if not provided (e.g., 0.05).
    # cusum_h: CUSUM threshold. Set to None to let the detector calibrate it based on 'alpha'.
    
    detector = GEMDetector(k=10, s1_ratio=0.8, alpha=0.05, cusum_h=None, use_cuda=torch.cuda.is_available())

    # Fit GEM detector on the *full* nominal training data.
    # The detector will perform its own S1/S2 partitioning internally.
    detector.fit(nominal_training_data)
    print("âœ… GEM detector offline phase completed (trained and CUSUM calibrated).")

    # Perform detection on X_test using the trained detector
    # The predict method now returns a 2D array: [d_t_scores, binary_anomaly_declarations]
    detection_results = detector.predict(X_test)
    
    # Extract d_t scores for ROC/PR curve plotting and visualizations
    test_dt_scores = detection_results[:, 0]
    
    # Extract binary anomaly declarations from the CUSUM process
    y_pred = detection_results[:, 1].astype(int) 
    print("âœ… Anomaly detection performed on test data. Predictions generated by CUSUM.")

    # Evaluate detection
    y_true = np.asarray(y_test).astype(int)

    # Show classification report
    print("\nðŸ“Š Classification Report:")
    # target_names may need adjustment depending on your y_test labels (0 for Benign, 1 for Attack)
    print(classification_report(y_true, y_pred, target_names=["Benign", "Attack"]))

    print("\nðŸ“ˆ Generating visualization plots...")
    # plot_evaluation uses y_true and y_pred directly
    utils.plot_evaluation('GEM', y_true, y_pred)
    
    # plot_anomaly_detection_results needs the instantaneous scores (d_t) and the CUSUM threshold (h)
    utils.plot_anomaly_detection_results(anomaly_scores=test_dt_scores, 
                                         true_labels=y_true, 
                                         threshold=detector.cusum_h, # Use the calibrated CUSUM threshold h
                                         anomaly_label=1,
                                         threshold_label="CUSUM h") # Label the threshold clearly

    # ROC and PR curves are still based on the raw anomaly scores (d_t)
    utils.plot_roc_curve(anomaly_scores=test_dt_scores, true_labels=y_true, anomaly_label=1)
    utils.plot_precision_recall_curve(anomaly_scores=test_dt_scores, true_labels=y_true, anomaly_label=1)

    print("âœ… Visualization plot generated and displayed.")

if __name__ == '__main__':
    main()